# Configuration for mapping keys in older metadata files to our new template

# The format section states which file to use for the new template. It MUST
# be located in the same directory as this config file. It also specifies the 
# syntax of the user_data field. Whatever value is given must be used in the 
# config section below for any of the file types  if that file should be tucked
# into the user_data for a new document. 
# The constants tag tells it the name of the constants section to look for.

[format]
template = master_template.json
user_metadata_key = user_metadata
defaults_tag = default_vals

# The manager userid has to be looked up in the system groups finder, but the key
# can have a different name in our template than it does in the SGF's config.
manager_user_id_key = manager_user_id
user_id_key = user_id
sgf_manager_user_id_key = userid

source_path_key = source_path

# If an archived path isn't in the metadata, we might be able to just use the given
# directory name, if it's actually in the archive 
archive_path_key = archived_path
archive_root = /archive
archival_status_key = archival_status
archival_status_done_msg = completed

# We may have to add the date programmatically
date_key = date_archived

# The archived_size will definitely be added programmatically. WE MUST IGNORE THE 
# archived_size IN EXISTING METADATA FILES, BECAUSE IT WAS  INCORRECTLY WRITTEN IN
# BLOCKS INSTEAD OF BYTES.
archived_size_key = archived_size


# The system_groups key is it's own special case
system_groups_key = system_groups

# Some filenames contain a directory name, so the "dirname" string will need to be
# expanded to the actual directory name.
dirname_key = dirname

# There are different kinds of metadata in legacy, GT, singlecell, microscopy, etc. 
# The mapper must parse the given directory path to establish the category. If the 
# path matches one of the patterns in this section, it will be assigned the given 
# category
[categories]
/archive/GT/[0-9]{4} = gt
/archive/GT/amplidata_legacy = legacy
/archive/GT/aws_legacy = legacy
/archive/GT/legacy/(?!pacbio) = legacy
/archive/GT/legacy/pacbio = legacy_pacbio
/archive/services/microscopy = microscopy
/archive/services/singlecell/shares = singlecell
/archive/faculty = faculty


# We will skip any directories that match one of the excldue patterns.
exclude_patterns = \.old

# The doc names are the metadata documents the mapper will look for in a given
# directory. If found, it will read them, and use their values to populate the fields
# of the template.
[doc_names]
gt_metadata = gt-metadata.json
metadata = metadata.json
archived_json = archived.json
# There are odd cases, specifically for the 373 directories beneath 
# /archive/faculty/verhar-lab/amins/2019-11-12, where the metadata filename
# includes the directory name. I.e, i_E2CD-T1-A2-J01_metadata.json. 
# To keep the code kluges to a minimum, we'll just make a separate tag for those.
dirname_metadata = dirname_metadata.json



# Some template keys will refer to a date. Values will need to be converted to a 
# specific format
[dates]
date_key_pattern = ^when|^date
date_format = %%Y-%%m-%%d


[faculty_metadata]
classification = classification, data_classification, meta_doc > classification
grant_id = grant_id, meta_doc > grant_id
manager_user_id = manager_name, meta_doc > manager_user_id
project_name = project_name, meta_doc > project_name 
source_size = source_size
source_path = source_folder_path, meta_doc > source_folder_path 
user_metadata = True
user_id = manager_name, meta_doc > manager_user_id


[faculty_dirname_metadata]
classification = data_classification
grant_id = grant_id
manager_user_id = manager_user_id
project_name = project_name
source_size = source_folder_size
source_path = source_folder_path
user_metadata = True
user_id = manager_user_id


# Each section below tells the mapper which fields to try to get from which file.
[gt_gt_metadata]
manager_user_id = project > pi
notes = project > notes
project_name = project > customer_project_name_id
source_path = project > delivery_path
user_metadata = True
user_id = project > pi


[gt_archived_json]
archived_path = archived_path
date_archived = date_archived
source_size = source_folder_size

[gt_metadata]
classification = data_classification
grant_id = grant_id
manager_user_id = manager_user_id
source_size = source_size
source_path = source_folder_path
user_id = manager_user_id
user_metadata = True
date_archived = date_archived


[legacy_metadata]
archived_path = archived_path
grant_id = grant_id
manager_user_id = investigator_id
project_name = gt_project_name
source_size = source_folder_size
source_path = delivery_path
user_metadata = True
date_archived = date_archived


[legacy_pacbio_metadata]
archived_path = archived_path
manager_user_id = investigator_name
source_size = source_folder_size
source_path = delivery_path
user_id = investigator_name
user_metadata = True


[microscopy_metadata]
manager_user_id = lab,fs_lab
project_name = project
source_path = path,fs_path
user_id = lab,fs_lab
user_metadata = True


[singlecell_metadata]
classification = data_classification
grant_id = grant_id
manager_user_id = manager_user_id,fs_lab,lab
project_name = project
source_path = path,fs_path
source_size = source_size
user_id = manager_user_id,fs_lab,lab
user_metadata = True
date_archived = date_archived


# Constants will be used for fields that weren't yet populated. The values will be
# parsed and assigned the types preceding the colon
[default_vals]
archival_status = None:None
classification = None:None
failed_count = None:None
grant_id = None:None
source_size = None:None
submitter = dict:None


